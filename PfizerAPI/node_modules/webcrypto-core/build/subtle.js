"use strict";
var error_1 = require("./error");
var base_1 = require("./base");
var alg_1 = require("./alg");
var crypto_1 = require("./sha/crypto");
var crypto_2 = require("./rsa/crypto");
var crypto_3 = require("./aes/crypto");
var crypto_4 = require("./ec/crypto");
var crypto_5 = require("./hmac/crypto");
var crypto_6 = require("./pbkdf2/crypto");
var SubtleCrypto = (function () {
    function SubtleCrypto() {
    }
    SubtleCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaSSA.toUpperCase():
                    Class = crypto_2.RsaSSA;
                    break;
                case alg_1.AlgorithmNames.RsaOAEP.toUpperCase():
                    Class = crypto_2.RsaOAEP;
                    break;
                case alg_1.AlgorithmNames.RsaPSS.toUpperCase():
                    Class = crypto_2.RsaPSS;
                    break;
                case alg_1.AlgorithmNames.AesCBC.toUpperCase():
                    Class = crypto_3.AesCBC;
                    break;
                case alg_1.AlgorithmNames.AesCTR.toUpperCase():
                    Class = crypto_3.AesCTR;
                    break;
                case alg_1.AlgorithmNames.AesGCM.toUpperCase():
                    Class = crypto_3.AesGCM;
                    break;
                case alg_1.AlgorithmNames.AesKW.toUpperCase():
                    Class = crypto_3.AesKW;
                    break;
                case alg_1.AlgorithmNames.EcDSA.toUpperCase():
                    Class = crypto_4.EcDSA;
                    break;
                case alg_1.AlgorithmNames.EcDH.toUpperCase():
                    Class = crypto_4.EcDH;
                    break;
                case alg_1.AlgorithmNames.Hmac.toUpperCase():
                    Class = crypto_5.Hmac;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.generateKey(alg, extractable, keyUsages).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.digest = function (algorithm, data) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var buf = base_1.PrepareData(data, "data");
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.Sha1.toUpperCase():
                case alg_1.AlgorithmNames.Sha256.toUpperCase():
                case alg_1.AlgorithmNames.Sha384.toUpperCase():
                case alg_1.AlgorithmNames.Sha512.toUpperCase():
                    Class = crypto_1.Sha;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.digest(alg, buf).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.sign = function (algorithm, key, data) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var buf = base_1.PrepareData(data, "data");
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaSSA.toUpperCase():
                    Class = crypto_2.RsaSSA;
                    break;
                case alg_1.AlgorithmNames.RsaPSS.toUpperCase():
                    Class = crypto_2.RsaPSS;
                    break;
                case alg_1.AlgorithmNames.EcDSA.toUpperCase():
                    Class = crypto_4.EcDSA;
                    break;
                case alg_1.AlgorithmNames.Hmac.toUpperCase():
                    Class = crypto_5.Hmac;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.sign(alg, key, buf).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.verify = function (algorithm, key, signature, data) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var sigBuf = base_1.PrepareData(data, "signature");
            var buf = base_1.PrepareData(data, "data");
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaSSA.toUpperCase():
                    Class = crypto_2.RsaSSA;
                    break;
                case alg_1.AlgorithmNames.RsaPSS.toUpperCase():
                    Class = crypto_2.RsaPSS;
                    break;
                case alg_1.AlgorithmNames.EcDSA.toUpperCase():
                    Class = crypto_4.EcDSA;
                    break;
                case alg_1.AlgorithmNames.Hmac.toUpperCase():
                    Class = crypto_5.Hmac;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.verify(alg, key, sigBuf, buf).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.encrypt = function (algorithm, key, data) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var buf = base_1.PrepareData(data, "data");
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaOAEP.toUpperCase():
                    Class = crypto_2.RsaOAEP;
                    break;
                case alg_1.AlgorithmNames.AesCBC.toUpperCase():
                    Class = crypto_3.AesCBC;
                    break;
                case alg_1.AlgorithmNames.AesCTR.toUpperCase():
                    Class = crypto_3.AesCTR;
                    break;
                case alg_1.AlgorithmNames.AesGCM.toUpperCase():
                    Class = crypto_3.AesGCM;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.encrypt(alg, key, buf).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.decrypt = function (algorithm, key, data) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var buf = base_1.PrepareData(data, "data");
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaOAEP.toUpperCase():
                    Class = crypto_2.RsaOAEP;
                    break;
                case alg_1.AlgorithmNames.AesCBC.toUpperCase():
                    Class = crypto_3.AesCBC;
                    break;
                case alg_1.AlgorithmNames.AesCTR.toUpperCase():
                    Class = crypto_3.AesCTR;
                    break;
                case alg_1.AlgorithmNames.AesGCM.toUpperCase():
                    Class = crypto_3.AesGCM;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.decrypt(alg, key, buf).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.deriveBits = function (algorithm, baseKey, length) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.EcDH.toUpperCase():
                    Class = crypto_4.EcDH;
                    break;
                case alg_1.AlgorithmNames.Pbkdf2.toUpperCase():
                    Class = crypto_6.Pbkdf2;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.deriveBits(alg, baseKey, length).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var derivedAlg = base_1.PrepareAlgorithm(derivedKeyType);
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.EcDH.toUpperCase():
                    Class = crypto_4.EcDH;
                    break;
                case alg_1.AlgorithmNames.Pbkdf2.toUpperCase():
                    Class = crypto_6.Pbkdf2;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.deriveKey(alg, baseKey, derivedAlg, extractable, keyUsages).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.exportKey = function (format, key) {
        return new Promise(function (resolve, reject) {
            base_1.BaseCrypto.checkKey(key);
            if (!key.extractable)
                throw new error_1.CryptoKeyError(error_1.CryptoKeyError.NOT_EXTRACTABLE);
            var Class = base_1.BaseCrypto;
            switch (key.algorithm.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaSSA.toUpperCase():
                    Class = crypto_2.RsaSSA;
                    break;
                case alg_1.AlgorithmNames.RsaPSS.toUpperCase():
                    Class = crypto_2.RsaPSS;
                    break;
                case alg_1.AlgorithmNames.RsaOAEP.toUpperCase():
                    Class = crypto_2.RsaOAEP;
                    break;
                case alg_1.AlgorithmNames.AesCBC.toUpperCase():
                    Class = crypto_3.AesCBC;
                    break;
                case alg_1.AlgorithmNames.AesCTR.toUpperCase():
                    Class = crypto_3.AesCTR;
                    break;
                case alg_1.AlgorithmNames.AesGCM.toUpperCase():
                    Class = crypto_3.AesGCM;
                    break;
                case alg_1.AlgorithmNames.AesKW.toUpperCase():
                    Class = crypto_3.AesKW;
                    break;
                case alg_1.AlgorithmNames.EcDSA.toUpperCase():
                    Class = crypto_4.EcDSA;
                    break;
                case alg_1.AlgorithmNames.EcDH.toUpperCase():
                    Class = crypto_4.EcDH;
                    break;
                case alg_1.AlgorithmNames.Hmac.toUpperCase():
                    Class = crypto_5.Hmac;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, key.algorithm.name);
            }
            Class.exportKey(format, key).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(algorithm);
            var Class = base_1.BaseCrypto;
            // TODO prepare keyData
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaSSA.toUpperCase():
                    Class = crypto_2.RsaSSA;
                    break;
                case alg_1.AlgorithmNames.RsaPSS.toUpperCase():
                    Class = crypto_2.RsaPSS;
                    break;
                case alg_1.AlgorithmNames.RsaOAEP.toUpperCase():
                    Class = crypto_2.RsaOAEP;
                    break;
                case alg_1.AlgorithmNames.AesCBC.toUpperCase():
                    Class = crypto_3.AesCBC;
                    break;
                case alg_1.AlgorithmNames.AesCTR.toUpperCase():
                    Class = crypto_3.AesCTR;
                    break;
                case alg_1.AlgorithmNames.AesGCM.toUpperCase():
                    Class = crypto_3.AesGCM;
                    break;
                case alg_1.AlgorithmNames.AesKW.toUpperCase():
                    Class = crypto_3.AesKW;
                    break;
                case alg_1.AlgorithmNames.EcDSA.toUpperCase():
                    Class = crypto_4.EcDSA;
                    break;
                case alg_1.AlgorithmNames.EcDH.toUpperCase():
                    Class = crypto_4.EcDH;
                    break;
                case alg_1.AlgorithmNames.Hmac.toUpperCase():
                    Class = crypto_5.Hmac;
                    break;
                case alg_1.AlgorithmNames.Pbkdf2.toUpperCase():
                    Class = crypto_6.Pbkdf2;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.importKey(format, keyData, alg, extractable, keyUsages).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
        return new Promise(function (resolve, reject) {
            var alg = base_1.PrepareAlgorithm(wrapAlgorithm);
            var Class = base_1.BaseCrypto;
            switch (alg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaOAEP.toUpperCase():
                    Class = crypto_2.RsaOAEP;
                    break;
                case alg_1.AlgorithmNames.AesCBC.toUpperCase():
                    Class = crypto_3.AesCBC;
                    break;
                case alg_1.AlgorithmNames.AesCTR.toUpperCase():
                    Class = crypto_3.AesCTR;
                    break;
                case alg_1.AlgorithmNames.AesGCM.toUpperCase():
                    Class = crypto_3.AesGCM;
                    break;
                case alg_1.AlgorithmNames.AesKW.toUpperCase():
                    Class = crypto_3.AesKW;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, alg.name);
            }
            Class.wrapKey(format, key, wrappingKey, alg).then(resolve, reject);
        });
    };
    SubtleCrypto.prototype.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var unwrapAlg = base_1.PrepareAlgorithm(unwrapAlgorithm);
            var unwrappedAlg = base_1.PrepareAlgorithm(unwrappedKeyAlgorithm);
            var buf = base_1.PrepareData(wrappedKey, "wrappedKey");
            var Class = base_1.BaseCrypto;
            switch (unwrapAlg.name.toUpperCase()) {
                case alg_1.AlgorithmNames.RsaOAEP.toUpperCase():
                    Class = crypto_2.RsaOAEP;
                    break;
                case alg_1.AlgorithmNames.AesCBC.toUpperCase():
                    Class = crypto_3.AesCBC;
                    break;
                case alg_1.AlgorithmNames.AesCTR.toUpperCase():
                    Class = crypto_3.AesCTR;
                    break;
                case alg_1.AlgorithmNames.AesGCM.toUpperCase():
                    Class = crypto_3.AesGCM;
                    break;
                case alg_1.AlgorithmNames.AesKW.toUpperCase():
                    Class = crypto_3.AesKW;
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, unwrapAlg.name);
            }
            Class.unwrapKey(format, buf, unwrappingKey, unwrapAlg, unwrappedAlg, extractable, keyUsages).then(resolve, reject);
        });
    };
    return SubtleCrypto;
}());
exports.SubtleCrypto = SubtleCrypto;
