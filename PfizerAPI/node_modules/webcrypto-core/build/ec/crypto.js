"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var crypto_1 = require("../aes/crypto");
var crypto_2 = require("../sha/crypto");
var error_1 = require("../error");
var base_1 = require("../base");
var alg_1 = require("../alg");
var EcKeyGenParamsError = (function (_super) {
    __extends(EcKeyGenParamsError, _super);
    function EcKeyGenParamsError() {
        var _this = _super.apply(this, arguments) || this;
        _this.code = 9;
        return _this;
    }
    return EcKeyGenParamsError;
}(error_1.AlgorithmError));
exports.EcKeyGenParamsError = EcKeyGenParamsError;
var Ec = (function (_super) {
    __extends(Ec, _super);
    function Ec() {
        return _super.apply(this, arguments) || this;
    }
    Ec.checkAlgorithm = function (alg) {
        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase())
            throw new error_1.AlgorithmError(error_1.AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);
    };
    Ec.checkKeyGenParams = function (alg) {
        var param_namedCurve = "namedCurve";
        if (!alg.namedCurve)
            throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_REQUIRED, param_namedCurve);
        if (!(typeof alg.namedCurve === "string"))
            throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_WRONG_TYPE, param_namedCurve, "string");
        switch (alg.namedCurve.toUpperCase()) {
            case "P-256":
            case "P-384":
            case "P-521":
                break;
            default:
                throw new EcKeyGenParamsError(EcKeyGenParamsError.PARAM_WRONG_VALUE, param_namedCurve, "P-256, P-384 or P-521");
        }
    };
    Ec.checkKeyGenUsages = function (keyUsages) {
        var _this = this;
        keyUsages.forEach(function (usage) {
            var i = 0;
            for (i; i < _this.KEY_USAGES.length; i++)
                if (_this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {
                    break;
                }
            if (i === _this.KEY_USAGES.length)
                throw new error_1.WebCryptoError("Unsuported key usage '" + usage + "'. Should be one of [" + _this.KEY_USAGES.join(", ") + "]");
        });
    };
    Ec.generateKey = function (algorithm, extractable, keyUsages) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithm(algorithm);
            _this.checkKeyGenParams(algorithm);
            _this.checkKeyGenUsages(keyUsages);
            resolve(undefined);
        });
    };
    Ec.exportKey = function (format, key) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkKey(key, _this.ALG_NAME);
            _this.checkFormat(format, key.type);
            resolve(undefined);
        });
    };
    Ec.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkKeyGenParams(algorithm);
            _this.checkFormat(format);
            if (format.toLowerCase() === "raw")
                throw new error_1.CryptoKeyError(error_1.CryptoKeyError.ALLOWED_FORMAT, format, "'JsonWebKey', 'pkcs8' or 'spki'");
            _this.checkKeyGenUsages(keyUsages);
            resolve(undefined);
        });
    };
    return Ec;
}(base_1.BaseCrypto));
Ec.ALG_NAME = "";
Ec.KEY_USAGES = [];
exports.Ec = Ec;
var EcAlgorithmError = (function (_super) {
    __extends(EcAlgorithmError, _super);
    function EcAlgorithmError() {
        var _this = _super.apply(this, arguments) || this;
        _this.code = 10;
        return _this;
    }
    return EcAlgorithmError;
}(error_1.AlgorithmError));
exports.EcAlgorithmError = EcAlgorithmError;
var EcDSA = (function (_super) {
    __extends(EcDSA, _super);
    function EcDSA() {
        return _super.apply(this, arguments) || this;
    }
    EcDSA.checkAlgorithmParams = function (alg) {
        this.checkAlgorithm(alg);
        crypto_2.Sha.checkAlgorithm(alg.hash);
    };
    EcDSA.sign = function (algorithm, key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(algorithm);
            _this.checkKey(key, _this.ALG_NAME, "private", "sign");
            resolve(undefined);
        });
    };
    EcDSA.verify = function (algorithm, key, signature, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(algorithm);
            _this.checkKey(key, _this.ALG_NAME, "public", "verify");
            resolve(undefined);
        });
    };
    return EcDSA;
}(Ec));
EcDSA.ALG_NAME = alg_1.AlgorithmNames.EcDSA;
EcDSA.KEY_USAGES = ["sign", "verify", "deriveKey", "deriveBits"];
exports.EcDSA = EcDSA;
var EcDH = (function (_super) {
    __extends(EcDH, _super);
    function EcDH() {
        return _super.apply(this, arguments) || this;
    }
    EcDH.checkDeriveParams = function (algorithm) {
        var param_public = "public";
        this.checkAlgorithm(algorithm);
        if (!algorithm.public)
            throw new EcAlgorithmError(EcAlgorithmError.PARAM_REQUIRED, param_public);
        this.checkKey(algorithm.public, this.ALG_NAME, "public");
    };
    EcDH.deriveBits = function (algorithm, baseKey, length) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkDeriveParams(algorithm);
            _this.checkKey(baseKey, _this.ALG_NAME, "private", "deriveBits");
            resolve(undefined);
        });
    };
    EcDH.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkDeriveParams(algorithm);
            _this.checkKey(baseKey, _this.ALG_NAME, "private", "deriveKey");
            base_1.BaseCrypto.checkAlgorithm(derivedKeyType);
            switch (derivedKeyType.name.toUpperCase()) {
                case alg_1.AlgorithmNames.AesCBC:
                    crypto_1.AesCBC.checkKeyGenParams(derivedKeyType);
                    break;
                case alg_1.AlgorithmNames.AesCTR:
                    crypto_1.AesCTR.checkKeyGenParams(derivedKeyType);
                    break;
                case alg_1.AlgorithmNames.AesGCM:
                    crypto_1.AesGCM.checkKeyGenParams(derivedKeyType);
                    break;
                case alg_1.AlgorithmNames.AesKW:
                    crypto_1.AesKW.checkKeyGenParams(derivedKeyType);
                    break;
                default:
                    throw new EcAlgorithmError("Unsupported name '" + derivedKeyType.name + "' for algorithm in param 'derivedKeyType'");
            }
            resolve(undefined);
        });
    };
    return EcDH;
}(Ec));
EcDH.ALG_NAME = alg_1.AlgorithmNames.EcDH;
EcDH.KEY_USAGES = ["deriveKey", "deriveBits"];
exports.EcDH = EcDH;
