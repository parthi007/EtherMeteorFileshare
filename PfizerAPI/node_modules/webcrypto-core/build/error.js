"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
function printf(text) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var msg = text;
    var regFind = /[^%](%\d+)/g;
    var match;
    var matches = [];
    while (match = regFind.exec(msg)) {
        matches.push({ arg: match[1], index: match.index });
    }
    // replace matches
    for (var i = matches.length - 1; i >= 0; i--) {
        var item = matches[i];
        var arg = item.arg.substring(1);
        var index = item.index + 1;
        msg = msg.substring(0, index) + arguments[+arg] + msg.substring(index + 1 + arg.length);
    }
    // convert %% -> %
    msg = msg.replace("%%", "%");
    return msg;
}
var WebCryptoError = (function (_super) {
    __extends(WebCryptoError, _super);
    function WebCryptoError(template) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _this = _super.call(this) || this;
        _this.code = 0;
        _this.message = printf.apply(void 0, [template].concat(args));
        var error = new Error(_this.message);
        error.name = _this["constructor"].name;
        _this.stack = error.stack;
        return _this;
    }
    return WebCryptoError;
}(Error));
WebCryptoError.NOT_SUPPORTED = "Method is not supported";
exports.WebCryptoError = WebCryptoError;
var AlgorithmError = (function (_super) {
    __extends(AlgorithmError, _super);
    function AlgorithmError() {
        var _this = _super.apply(this, arguments) || this;
        _this.code = 1;
        return _this;
    }
    return AlgorithmError;
}(WebCryptoError));
AlgorithmError.PARAM_REQUIRED = "Algorithm hasn't got required paramter '%1'";
AlgorithmError.PARAM_WRONG_TYPE = "Algorithm has got wrong type for paramter '%1'. Must be %2";
AlgorithmError.PARAM_WRONG_VALUE = "Algorithm has got wrong value for paramter '%1'. Must be %2";
AlgorithmError.WRONG_ALG_NAME = "Algorithm has got wrong name '%1'. Must be '%2'";
AlgorithmError.UNSUPPORTED_ALGORITHM = "Algorithm '%1' is not supported";
AlgorithmError.WRONG_USAGE = "Algorithm doesn't support key usage '%1'";
exports.AlgorithmError = AlgorithmError;
var CryptoKeyError = (function (_super) {
    __extends(CryptoKeyError, _super);
    function CryptoKeyError() {
        var _this = _super.apply(this, arguments) || this;
        _this.code = 3;
        return _this;
    }
    return CryptoKeyError;
}(WebCryptoError));
CryptoKeyError.EMPTY_KEY = "CryptoKey is empty";
CryptoKeyError.WRONG_KEY_ALG = "CryptoKey has wrong algorithm '%1'. Must be '%2'";
CryptoKeyError.WRONG_KEY_TYPE = "CryptoKey has wrong type '%1'. Must be '%2'";
CryptoKeyError.WRONG_KEY_USAGE = "CryptoKey has wrong key usage. Must be '%1'";
CryptoKeyError.NOT_EXTRACTABLE = "CryptoKey is not extractable";
CryptoKeyError.WRONG_FORMAT = "CryptoKey has '%1' type. It can be used with '%2' format";
CryptoKeyError.UNKNOWN_FORMAT = "Uknown format in use '%1'. Must be one of 'raw', 'pkcs8', 'spki'  or 'jwk'";
CryptoKeyError.ALLOWED_FORMAT = "Wrong format value '%1'. Must be %2";
exports.CryptoKeyError = CryptoKeyError;
