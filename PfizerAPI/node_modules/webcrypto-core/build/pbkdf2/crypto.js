"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var error_1 = require("../error");
var base_1 = require("../base");
var base_2 = require("../base");
var alg_1 = require("../alg");
var crypto_1 = require("../sha/crypto");
var Aes = require("../aes/crypto");
var crypto_2 = require("../hmac/crypto");
var Pbkdf2 = (function (_super) {
    __extends(Pbkdf2, _super);
    function Pbkdf2() {
        return _super.apply(this, arguments) || this;
    }
    Pbkdf2.checkAlgorithm = function (alg) {
        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase())
            throw new error_1.AlgorithmError(error_1.AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);
    };
    Pbkdf2.checkDeriveParams = function (alg) {
        this.checkAlgorithm(alg);
        // salt
        if (alg.salt) {
            if (!(ArrayBuffer.isView(alg.salt) || alg.salt instanceof ArrayBuffer))
                throw new error_1.AlgorithmError(error_1.AlgorithmError.PARAM_WRONG_TYPE, "salt", "ArrayBuffer or ArrayBufferView");
        }
        else
            throw new error_1.AlgorithmError(error_1.AlgorithmError.PARAM_REQUIRED, "salt");
        // iterations
        if (!alg.iterations)
            throw new error_1.AlgorithmError(error_1.AlgorithmError.PARAM_REQUIRED, "iterations");
        // hash
        if (!alg.hash)
            throw new error_1.AlgorithmError(error_1.AlgorithmError.PARAM_REQUIRED, "hash");
        var hash = base_1.PrepareAlgorithm(alg.hash);
        crypto_1.Sha.checkAlgorithm(hash);
    };
    Pbkdf2.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            if (extractable)
                throw new error_1.WebCryptoError("KDF keys must set extractable=false");
            _this.checkAlgorithm(algorithm);
            _this.checkFormat(format);
            if (format.toLowerCase() !== "raw")
                throw new error_1.CryptoKeyError(error_1.CryptoKeyError.ALLOWED_FORMAT, format, "'raw'");
            _this.checkKeyUsages(keyUsages);
        });
    };
    Pbkdf2.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            _this.checkDeriveParams(algorithm);
            _this.checkKey(baseKey, _this.ALG_NAME, "secret", "deriveKey");
            base_2.BaseCrypto.checkAlgorithm(derivedKeyType);
            // AES-CTR, AES-CBC, AES-CMAC, AES-GCM, AES-CFB, AES-KW, ECDH, DH, or HMAC
            switch (derivedKeyType.name.toUpperCase()) {
                case alg_1.AlgorithmNames.AesCBC:
                    Aes.AesCBC.checkKeyGenParams(derivedKeyType);
                    Aes.AesCBC.checkKeyUsages(keyUsages);
                    break;
                case alg_1.AlgorithmNames.AesCTR:
                    Aes.AesCTR.checkKeyGenParams(derivedKeyType);
                    Aes.AesCTR.checkKeyUsages(keyUsages);
                    break;
                case alg_1.AlgorithmNames.AesGCM:
                    Aes.AesGCM.checkKeyGenParams(derivedKeyType);
                    Aes.AesGCM.checkKeyUsages(keyUsages);
                    break;
                case alg_1.AlgorithmNames.AesKW:
                    Aes.AesKW.checkKeyGenParams(derivedKeyType);
                    Aes.AesKW.checkKeyUsages(keyUsages);
                    break;
                case alg_1.AlgorithmNames.Hmac:
                    crypto_2.Hmac.checkKeyGenParams(derivedKeyType);
                    crypto_2.Hmac.checkKeyUsages(keyUsages);
                    break;
                default:
                    throw new error_1.AlgorithmError(error_1.AlgorithmError.UNSUPPORTED_ALGORITHM, derivedKeyType);
            }
        });
    };
    Pbkdf2.deriveBits = function (algorithm, baseKey, length) {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            _this.checkDeriveParams(algorithm);
            _this.checkKey(baseKey, _this.ALG_NAME, "secret", "deriveBits");
            if (!(length && typeof length === "number"))
                throw new error_1.WebCryptoError("Parameter 'length' must be Number and more than 0");
        });
    };
    return Pbkdf2;
}(base_2.BaseCrypto));
Pbkdf2.ALG_NAME = alg_1.AlgorithmNames.Pbkdf2;
Pbkdf2.KEY_USAGES = ["deriveKey", "deriveBits"];
exports.Pbkdf2 = Pbkdf2;
