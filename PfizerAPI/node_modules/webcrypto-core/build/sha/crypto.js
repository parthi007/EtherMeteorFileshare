"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var alg_1 = require("../alg");
var base_1 = require("../base");
var error_1 = require("../error");
exports.ShaAlgorithms = [alg_1.AlgorithmNames.Sha1, alg_1.AlgorithmNames.Sha256, alg_1.AlgorithmNames.Sha384, alg_1.AlgorithmNames.Sha512].join(" | ");
var Sha = (function (_super) {
    __extends(Sha, _super);
    function Sha() {
        return _super.apply(this, arguments) || this;
    }
    Sha.checkAlgorithm = function (alg) {
        var _alg;
        if (typeof alg === "string")
            _alg = { name: alg };
        else
            _alg = alg;
        _super.checkAlgorithm.call(this, _alg);
        switch (_alg.name.toUpperCase()) {
            case alg_1.AlgorithmNames.Sha1:
            case alg_1.AlgorithmNames.Sha256:
            case alg_1.AlgorithmNames.Sha384:
            case alg_1.AlgorithmNames.Sha512:
                break;
            default:
                throw new error_1.AlgorithmError(error_1.AlgorithmError.WRONG_ALG_NAME, _alg.name, exports.ShaAlgorithms);
        }
    };
    Sha.digest = function (algorithm, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithm(algorithm);
            resolve(undefined);
        });
    };
    return Sha;
}(base_1.BaseCrypto));
exports.Sha = Sha;
