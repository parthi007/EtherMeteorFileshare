"use strict";
var error_1 = require("./error");
function PrepareAlgorithm(alg) {
    var res;
    if (typeof alg === "string")
        res = { name: alg };
    else
        res = alg;
    BaseCrypto.checkAlgorithm(res);
    var hashedAlg = alg;
    if (hashedAlg.hash) {
        hashedAlg.hash = PrepareAlgorithm(hashedAlg.hash);
    }
    return res;
}
exports.PrepareAlgorithm = PrepareAlgorithm;
function PrepareData(data, paramName) {
    if (!data)
        throw new error_1.WebCryptoError("Parameter '" + paramName + "' is required and cant be empty");
    if (ArrayBuffer.isView(data))
        return new Uint8Array(data.buffer);
    if (data instanceof ArrayBuffer)
        return new Uint8Array(data);
    throw new error_1.WebCryptoError("Incoming parameter '" + paramName + "' has wrong data type. Must be ArrayBufferView or ArrayBuffer");
}
exports.PrepareData = PrepareData;
var BaseCrypto = (function () {
    function BaseCrypto() {
    }
    BaseCrypto.checkAlgorithm = function (alg) {
        if (typeof alg !== "object")
            throw new TypeError("Wrong algorithm data type. Must be Object");
        if (!("name" in alg))
            throw new error_1.AlgorithmError(error_1.AlgorithmError.PARAM_REQUIRED, "name");
    };
    BaseCrypto.checkAlgorithmParams = function (alg) {
        this.checkAlgorithm(alg);
    };
    BaseCrypto.checkKey = function (key, alg, type, usage) {
        if (type === void 0) { type = null; }
        if (usage === void 0) { usage = null; }
        // check key empty
        if (!key)
            throw new error_1.CryptoKeyError(error_1.CryptoKeyError.EMPTY_KEY);
        // check alg
        var keyAlg = key.algorithm;
        this.checkAlgorithm(keyAlg);
        if (alg && (keyAlg.name.toUpperCase() !== alg.toUpperCase()))
            throw new error_1.CryptoKeyError(error_1.CryptoKeyError.WRONG_KEY_ALG, keyAlg.name, alg);
        // check type
        if (type && (!key.type || key.type.toUpperCase() !== type.toUpperCase()))
            throw new error_1.CryptoKeyError(error_1.CryptoKeyError.WRONG_KEY_TYPE, key.type, type);
        // check usage
        if (usage) {
            if (!key.usages.some(function (keyUsage) { return usage.toUpperCase() === keyUsage.toUpperCase(); }))
                throw new error_1.CryptoKeyError(error_1.CryptoKeyError.WRONG_KEY_USAGE, usage);
        }
    };
    BaseCrypto.checkWrappedKey = function (key) {
        if (!key.extractable)
            throw new error_1.CryptoKeyError(error_1.CryptoKeyError.NOT_EXTRACTABLE);
    };
    BaseCrypto.checkKeyUsages = function (keyUsages) {
        if (!keyUsages || !keyUsages.length)
            throw new error_1.WebCryptoError("Parameter 'keyUsages' cannot be empty.");
    };
    BaseCrypto.checkFormat = function (format, type) {
        switch (format.toLowerCase()) {
            case "raw":
                if (type && type.toLowerCase() !== "secret")
                    throw new error_1.CryptoKeyError(error_1.CryptoKeyError.WRONG_FORMAT, type, "raw");
                break;
            case "pkcs8":
                if (type && type.toLowerCase() !== "private")
                    throw new error_1.CryptoKeyError(error_1.CryptoKeyError.WRONG_FORMAT, type, "pkcs8");
                break;
            case "spki":
                if (type && type.toLowerCase() !== "public")
                    throw new error_1.CryptoKeyError(error_1.CryptoKeyError.WRONG_FORMAT, type, "spki");
                break;
            case "jwk":
                break;
            default:
                throw new error_1.CryptoKeyError(error_1.CryptoKeyError.UNKNOWN_FORMAT, format);
        }
    };
    BaseCrypto.generateKey = function (algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.digest = function (algorithm, data) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.sign = function (algorithm, key, data) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.verify = function (algorithm, key, signature, data) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.encrypt = function (algorithm, key, data) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.decrypt = function (algorithm, key, data) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.deriveBits = function (algorithm, baseKey, length) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.exportKey = function (format, key) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    BaseCrypto.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            throw new error_1.WebCryptoError(error_1.WebCryptoError.NOT_SUPPORTED);
        });
    };
    return BaseCrypto;
}());
exports.BaseCrypto = BaseCrypto;
