"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var error_1 = require("../error");
var base_1 = require("../base");
var alg_1 = require("../alg");
var crypto_1 = require("../sha/crypto");
var RsaKeyGenParamsError = (function (_super) {
    __extends(RsaKeyGenParamsError, _super);
    function RsaKeyGenParamsError() {
        var _this = _super.apply(this, arguments) || this;
        _this.code = 2;
        return _this;
    }
    return RsaKeyGenParamsError;
}(error_1.AlgorithmError));
exports.RsaKeyGenParamsError = RsaKeyGenParamsError;
var RsaHashedImportParamsError = (function (_super) {
    __extends(RsaHashedImportParamsError, _super);
    function RsaHashedImportParamsError() {
        var _this = _super.apply(this, arguments) || this;
        _this.code = 6;
        return _this;
    }
    return RsaHashedImportParamsError;
}(error_1.AlgorithmError));
exports.RsaHashedImportParamsError = RsaHashedImportParamsError;
var Rsa = (function (_super) {
    __extends(Rsa, _super);
    function Rsa() {
        return _super.apply(this, arguments) || this;
    }
    Rsa.checkAlgorithm = function (alg) {
        if (alg.name.toUpperCase() !== this.ALG_NAME.toUpperCase())
            throw new error_1.AlgorithmError(error_1.AlgorithmError.WRONG_ALG_NAME, alg.name, this.ALG_NAME);
    };
    Rsa.checkImportAlgorithm = function (alg) {
        /**
         * Check alg name. Use the same way as Chrome uses.
         * It throws error if algorithm doesn't have a `name` paramter
         * But it's not a equal to W3 specification
         * https://www.w3.org/TR/WebCryptoAPI/#dfn-RsaHashedImportParams
         *
         */
        this.checkAlgorithm(alg);
        if (!alg.hash)
            throw new RsaHashedImportParamsError(RsaHashedImportParamsError.PARAM_REQUIRED, "hash");
        crypto_1.Sha.checkAlgorithm(alg.hash);
    };
    Rsa.checkKeyGenParams = function (alg) {
        // modulusLength
        switch (alg.modulusLength) {
            case 1024:
            case 2048:
            case 4096:
                break;
            default:
                throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_VALUE, "modulusLength", "1024, 2048 or 4096");
        }
        // publicExponent
        var pubExp = alg.publicExponent;
        if (!pubExp)
            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_REQUIRED, "publicExponent");
        if (!ArrayBuffer.isView(pubExp))
            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_TYPE, "publicExponent", "ArrayBufferView");
        if (!(pubExp[0] === 3 || (pubExp[0] === 1 && pubExp[1] === 0 && pubExp[2] === 1)))
            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_WRONG_VALUE, "publicExponent", "Uint8Array([3]) | Uint8Array([1, 0, 1])");
        // hash
        if (!alg.hash)
            throw new RsaKeyGenParamsError(RsaKeyGenParamsError.PARAM_REQUIRED, "hash", crypto_1.ShaAlgorithms);
        crypto_1.Sha.checkAlgorithm(alg.hash);
    };
    Rsa.checkKeyGenUsages = function (keyUsages) {
        var _this = this;
        this.checkKeyUsages(keyUsages);
        keyUsages.forEach(function (usage) {
            var i = 0;
            for (i; i < _this.KEY_USAGES.length; i++)
                if (_this.KEY_USAGES[i].toLowerCase() === usage.toLowerCase()) {
                    break;
                }
            if (i === _this.KEY_USAGES.length)
                throw new error_1.WebCryptoError("Unsuported key usage '" + usage + "'. Should be one of [" + _this.KEY_USAGES.join(", ") + "]");
        });
    };
    Rsa.generateKey = function (algorithm, extractable, keyUsages) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithm(algorithm);
            _this.checkKeyGenParams(algorithm);
            _this.checkKeyGenUsages(keyUsages);
            resolve(undefined);
        });
    };
    Rsa.exportKey = function (format, key) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkKey(key, _this.ALG_NAME);
            _this.checkFormat(format, key.type);
            resolve(undefined);
        });
    };
    Rsa.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkImportAlgorithm(algorithm);
            _this.checkFormat(format);
            if (format.toLowerCase() === "raw")
                throw new error_1.CryptoKeyError(error_1.CryptoKeyError.ALLOWED_FORMAT, format, "'JsonWebKey', 'pkcs8' or 'spki'");
            _this.checkKeyGenUsages(keyUsages);
            resolve(undefined);
        });
    };
    return Rsa;
}(base_1.BaseCrypto));
Rsa.ALG_NAME = "";
Rsa.KEY_USAGES = [];
exports.Rsa = Rsa;
var RsaSSA = (function (_super) {
    __extends(RsaSSA, _super);
    function RsaSSA() {
        return _super.apply(this, arguments) || this;
    }
    RsaSSA.sign = function (algorithm, key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(algorithm);
            _this.checkKey(key, _this.ALG_NAME, "private", "sign");
            resolve(undefined);
        });
    };
    RsaSSA.verify = function (algorithm, key, signature, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(algorithm);
            _this.checkKey(key, _this.ALG_NAME, "public", "verify");
            resolve(undefined);
        });
    };
    return RsaSSA;
}(Rsa));
RsaSSA.ALG_NAME = alg_1.AlgorithmNames.RsaSSA;
RsaSSA.KEY_USAGES = ["sign", "verify"];
exports.RsaSSA = RsaSSA;
var RsaPSSParamsError = (function (_super) {
    __extends(RsaPSSParamsError, _super);
    function RsaPSSParamsError() {
        var _this = _super.apply(this, arguments) || this;
        _this.code = 4;
        return _this;
    }
    return RsaPSSParamsError;
}(error_1.AlgorithmError));
exports.RsaPSSParamsError = RsaPSSParamsError;
var RsaPSS = (function (_super) {
    __extends(RsaPSS, _super);
    function RsaPSS() {
        return _super.apply(this, arguments) || this;
    }
    RsaPSS.checkRsaPssParams = function (alg) {
        /**
         * TODO: Check alg verification in browser
         */
        _super.checkAlgorithmParams.call(this, alg);
        if (!alg.saltLength)
            return new RsaPSSParamsError(RsaPSSParamsError.PARAM_REQUIRED, "saltLength");
        if (alg.saltLength % 8)
            return new RsaPSSParamsError("Parameter 'saltLength' should be a multiple of 8");
    };
    return RsaPSS;
}(RsaSSA));
RsaPSS.ALG_NAME = alg_1.AlgorithmNames.RsaPSS;
RsaPSS.KEY_USAGES = ["sign", "verify"];
exports.RsaPSS = RsaPSS;
var RsaOAEPParamsError = (function (_super) {
    __extends(RsaOAEPParamsError, _super);
    function RsaOAEPParamsError() {
        var _this = _super.apply(this, arguments) || this;
        _this.code = 5;
        return _this;
    }
    return RsaOAEPParamsError;
}(error_1.AlgorithmError));
exports.RsaOAEPParamsError = RsaOAEPParamsError;
var RsaOAEP = (function (_super) {
    __extends(RsaOAEP, _super);
    function RsaOAEP() {
        return _super.apply(this, arguments) || this;
    }
    RsaOAEP.checkAlgorithmParams = function (alg) {
        if (alg.label) {
            if (!ArrayBuffer.isView(alg.label))
                return new RsaOAEPParamsError(RsaOAEPParamsError.PARAM_WRONG_TYPE, "label", "ArrayBufferView");
        }
    };
    RsaOAEP.encrypt = function (algorithm, key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(algorithm);
            _this.checkKey(key, _this.ALG_NAME, "public", "encrypt");
            resolve(undefined);
        });
    };
    RsaOAEP.decrypt = function (algorithm, key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(algorithm);
            _this.checkKey(key, _this.ALG_NAME, "private", "decrypt");
            resolve(undefined);
        });
    };
    RsaOAEP.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(wrapAlgorithm);
            _this.checkKey(wrappingKey, _this.ALG_NAME, "public", "wrapKey");
            _this.checkWrappedKey(key);
            _this.checkFormat(format, key.type);
            resolve(undefined);
        });
    };
    RsaOAEP.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.checkAlgorithmParams(unwrapAlgorithm);
            _this.checkKey(unwrappingKey, _this.ALG_NAME, "private", "unwrapKey");
            _this.checkFormat(format);
            // TODO check unwrappedKeyAlgorithm
            // TODO check keyUSages
            resolve(undefined);
        });
    };
    return RsaOAEP;
}(Rsa));
RsaOAEP.ALG_NAME = alg_1.AlgorithmNames.RsaOAEP;
RsaOAEP.KEY_USAGES = ["encrypt", "decrypt", "wrapKey", "unwrapKey"];
exports.RsaOAEP = RsaOAEP;
