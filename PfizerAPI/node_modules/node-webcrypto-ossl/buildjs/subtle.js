"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var webcrypto = require("webcrypto-core");
var AlgorithmError = webcrypto.AlgorithmError;
var PrepareAlgorithm = webcrypto.PrepareAlgorithm;
var BaseCrypto = webcrypto.BaseCrypto;
var AlgorithmNames = webcrypto.AlgorithmNames;
var native = require("./native");
var rsa = require("./crypto/rsa");
var aes = require("./crypto/aes");
var ec = require("./crypto/ec");
var hmac = require("./crypto/hmac");
var pbkdf2 = require("./crypto/pbkdf2");
function PrepareData(data) {
    return ab2b(data);
}
function ab2b(ab) {
    return new Buffer(ab);
}
var SubtleCrypto = (function (_super) {
    __extends(SubtleCrypto, _super);
    function SubtleCrypto() {
        return _super.apply(this, arguments) || this;
    }
    SubtleCrypto.prototype.digest = function (algorithm, data) {
        return _super.prototype.digest.apply(this, arguments)
            .then(function () {
            return new Promise(function (resolve, reject) {
                var _alg = PrepareAlgorithm(algorithm);
                var _data = PrepareData(data);
                var algName = _alg.name.toLowerCase();
                switch (algName) {
                    case "sha-1":
                    case "sha-224":
                    case "sha-256":
                    case "sha-384":
                    case "sha-512":
                        native.Core.digest(algName.replace("-", ""), _data, function (err, digest) {
                            if (err)
                                reject(err);
                            else
                                resolve(digest.buffer);
                        });
                        break;
                    default:
                        throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, algName);
                }
            });
        });
    };
    SubtleCrypto.prototype.generateKey = function (algorithm, extractable, keyUsages) {
        return _super.prototype.generateKey.apply(this, arguments)
            .then(function () {
            var _alg = PrepareAlgorithm(algorithm);
            var AlgClass;
            switch (_alg.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                case AlgorithmNames.AesGCM.toLowerCase():
                case AlgorithmNames.AesKW.toLowerCase():
                    AlgClass = aes.AesCrypto;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                case AlgorithmNames.Hmac.toLowerCase():
                    AlgClass = hmac.HmacCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _alg.name);
            }
            return AlgClass.generateKey(_alg, extractable, keyUsages);
        });
    };
    SubtleCrypto.prototype.sign = function (algorithm, key, data) {
        return _super.prototype.sign.apply(this, arguments)
            .then(function () {
            var _alg = PrepareAlgorithm(algorithm);
            var _data = PrepareData(data);
            var AlgClass;
            switch (_alg.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                case AlgorithmNames.Hmac.toLowerCase():
                    AlgClass = hmac.HmacCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _alg.name);
            }
            return AlgClass.sign(_alg, key, _data);
        });
    };
    SubtleCrypto.prototype.verify = function (algorithm, key, signature, data) {
        return _super.prototype.verify.apply(this, arguments)
            .then(function () {
            var _alg = PrepareAlgorithm(algorithm);
            var _signature = PrepareData(signature);
            var _data = PrepareData(data);
            var AlgClass;
            switch (_alg.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                case AlgorithmNames.Hmac.toLowerCase():
                    AlgClass = hmac.HmacCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _alg.name);
            }
            return AlgClass.verify(_alg, key, _signature, _data);
        });
    };
    SubtleCrypto.prototype.encrypt = function (algorithm, key, data) {
        return _super.prototype.encrypt.apply(this, arguments)
            .then(function () {
            var _alg = PrepareAlgorithm(algorithm);
            var _data = PrepareData(data);
            var AlgClass;
            switch (_alg.name.toLowerCase()) {
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                case AlgorithmNames.AesGCM.toLowerCase():
                case AlgorithmNames.AesKW.toLowerCase():
                    AlgClass = aes.AesCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _alg.name);
            }
            return AlgClass.encrypt(_alg, key, _data);
        });
    };
    SubtleCrypto.prototype.decrypt = function (algorithm, key, data) {
        return _super.prototype.decrypt.apply(this, arguments)
            .then(function () {
            var _alg = PrepareAlgorithm(algorithm);
            var _data = PrepareData(data);
            var AlgClass;
            switch (_alg.name.toLowerCase()) {
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                case AlgorithmNames.AesGCM.toLowerCase():
                case AlgorithmNames.AesKW.toLowerCase():
                    AlgClass = aes.AesCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _alg.name);
            }
            return AlgClass.decrypt(_alg, key, _data);
        });
    };
    SubtleCrypto.prototype.wrapKey = function (format, key, wrappingKey, wrapAlgorithm) {
        var _this = this;
        return _super.prototype.wrapKey.apply(this, arguments)
            .then(function () {
            return _this.exportKey(format, key)
                .then(function (exportedKey) {
                var _alg = webcrypto.PrepareAlgorithm(wrapAlgorithm);
                var _data;
                if (!(exportedKey instanceof ArrayBuffer)) {
                    _data = new Buffer(JSON.stringify(exportedKey));
                }
                else {
                    _data = new Buffer(exportedKey);
                }
                var CryptoClass;
                if (_alg.name.toUpperCase() === webcrypto.AlgorithmNames.AesKW)
                    CryptoClass = aes.AesCrypto;
                if (CryptoClass)
                    return CryptoClass.encrypt(_alg, wrappingKey, _data);
                else
                    return _this.encrypt(_alg, wrappingKey, _data);
            });
        });
    };
    SubtleCrypto.prototype.unwrapKey = function (format, wrappedKey, unwrappingKey, unwrapAlgorithm, unwrappedKeyAlgorithm, extractable, keyUsages) {
        var _this = this;
        return _super.prototype.unwrapKey.apply(this, arguments)
            .then(function () {
            return Promise.resolve()
                .then(function () {
                var _alg = webcrypto.PrepareAlgorithm(unwrapAlgorithm);
                var _data = PrepareData(wrappedKey);
                var CryptoClass;
                if (_alg.name.toUpperCase() === webcrypto.AlgorithmNames.AesKW)
                    CryptoClass = aes.AesCrypto;
                if (CryptoClass)
                    return CryptoClass.decrypt(_alg, unwrappingKey, _data);
                else
                    return _this.decrypt(_alg, unwrappingKey, _data);
            })
                .then(function (decryptedKey) {
                var keyData;
                if (format === "jwk") {
                    keyData = JSON.parse(new Buffer(decryptedKey).toString());
                }
                else {
                    keyData = new Buffer(decryptedKey);
                }
                return _this.importKey(format, keyData, unwrappedKeyAlgorithm, extractable, keyUsages);
            });
        });
    };
    SubtleCrypto.prototype.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
        return _super.prototype.deriveKey.apply(this, arguments)
            .then(function () {
            var _algorithm = PrepareAlgorithm(algorithm);
            var _derivedKeyType = PrepareAlgorithm(derivedKeyType);
            var AlgClass;
            switch (_algorithm.name.toLowerCase()) {
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                case AlgorithmNames.Pbkdf2.toLowerCase():
                    AlgClass = pbkdf2.Pbkdf2Crypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _algorithm.name);
            }
            return AlgClass.deriveKey(_algorithm, baseKey, _derivedKeyType, extractable, keyUsages);
        });
    };
    SubtleCrypto.prototype.deriveBits = function (algorithm, baseKey, length) {
        return _super.prototype.deriveBits.apply(this, arguments)
            .then(function () {
            var _algorithm = PrepareAlgorithm(algorithm);
            var AlgClass;
            switch (_algorithm.name.toLowerCase()) {
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                case AlgorithmNames.Pbkdf2.toLowerCase():
                    AlgClass = pbkdf2.Pbkdf2Crypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _algorithm.name);
            }
            return AlgClass.deriveBits(_algorithm, baseKey, length);
        });
    };
    SubtleCrypto.prototype.exportKey = function (format, key) {
        return _super.prototype.exportKey.apply(this, arguments)
            .then(function () {
            var AlgClass;
            switch (key.algorithm.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                case AlgorithmNames.AesGCM.toLowerCase():
                case AlgorithmNames.AesKW.toLowerCase():
                    AlgClass = aes.AesCrypto;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                case AlgorithmNames.Hmac.toLowerCase():
                    AlgClass = hmac.HmacCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, key.algorithm.name);
            }
            return AlgClass.exportKey(format, key);
        });
    };
    SubtleCrypto.prototype.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        return _super.prototype.importKey.apply(this, arguments)
            .then(function () {
            var _alg = PrepareAlgorithm(algorithm);
            var _data = keyData;
            if (format !== "jwk") {
                _data = PrepareData(_data);
            }
            var AlgClass;
            switch (_alg.name.toLowerCase()) {
                case AlgorithmNames.RsaSSA.toLowerCase():
                    AlgClass = rsa.RsaPKCS1;
                    break;
                case AlgorithmNames.RsaPSS.toLowerCase():
                    AlgClass = rsa.RsaPSS;
                    break;
                case AlgorithmNames.RsaOAEP.toLowerCase():
                    AlgClass = rsa.RsaOAEP;
                    break;
                case AlgorithmNames.AesCBC.toLowerCase():
                case AlgorithmNames.AesGCM.toLowerCase():
                case AlgorithmNames.AesKW.toLowerCase():
                    AlgClass = aes.AesCrypto;
                    break;
                case AlgorithmNames.EcDSA.toLowerCase():
                case AlgorithmNames.EcDH.toLowerCase():
                    AlgClass = ec.EcCrypto;
                    break;
                case AlgorithmNames.Hmac.toLowerCase():
                    AlgClass = hmac.HmacCrypto;
                    break;
                case AlgorithmNames.Pbkdf2.toLowerCase():
                    AlgClass = pbkdf2.Pbkdf2Crypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _alg.name);
            }
            return AlgClass.importKey(format, _data, _alg, extractable, keyUsages);
        });
    };
    return SubtleCrypto;
}(webcrypto.SubtleCrypto));
exports.SubtleCrypto = SubtleCrypto;
