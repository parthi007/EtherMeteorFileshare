"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var webcrypto_core_1 = require("webcrypto-core");
var key_1 = require("../key");
var native = require("../native");
function b64_decode(b64url) {
    return new Buffer(webcrypto_core_1.Base64Url.decode(b64url));
}
var AesCrypto = (function (_super) {
    __extends(AesCrypto, _super);
    function AesCrypto() {
        return _super.apply(this, arguments) || this;
    }
    AesCrypto.generateKey = function (algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            native.AesKey.generate(algorithm.length / 8, function (err, key) {
                if (err)
                    reject(err);
                else {
                    var aes = new key_1.CryptoKey(key, algorithm, "secret", extractable, keyUsages);
                    resolve(aes);
                }
            });
        });
    };
    AesCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var _format = format.toLocaleLowerCase();
            var raw;
            switch (_format) {
                case "jwk":
                    raw = b64_decode(keyData.k);
                    break;
                case "raw":
                    raw = keyData;
                    break;
                default:
                    throw new webcrypto_core_1.WebCryptoError("ImportKey: Wrong format value '" + format + "'");
            }
            algorithm.length = raw.byteLength * 8;
            native.AesKey.import(raw, function (err, key) {
                if (err)
                    reject(err);
                else
                    resolve(new key_1.CryptoKey(key, algorithm, "secret", extractable, keyUsages));
            });
        });
    };
    AesCrypto.exportKey = function (format, key) {
        return new Promise(function (resolve, reject) {
            var nkey = key.native;
            switch (format.toLocaleLowerCase()) {
                case "jwk":
                    var jwk_1 = {
                        kty: "oct",
                        alg: "",
                        key_ops: ["encrypt", "decrypt", "wrapKey", "unwrapKey"],
                        k: "",
                        ext: true
                    };
                    jwk_1.alg = "A" + key.algorithm.length + /-(\w+)$/.exec(key.algorithm.name)[1].toUpperCase();
                    nkey.export(function (err, data) {
                        if (err)
                            reject(err);
                        else {
                            jwk_1.k = webcrypto_core_1.Base64Url.encode(data);
                            resolve(jwk_1);
                        }
                    });
                    break;
                case "raw":
                    nkey.export(function (err, data) {
                        if (err)
                            reject(err);
                        else
                            resolve(data.buffer);
                    });
                    break;
                default: throw new webcrypto_core_1.WebCryptoError("ExportKey: Unknown export format '" + format + "'");
            }
        });
    };
    AesCrypto.EncryptDecrypt = function (algorithm, key, data, type) {
        return new Promise(function (resolve, reject) {
            var nkey = key.native;
            var iv = new Buffer(algorithm.iv);
            switch (algorithm.name.toLowerCase()) {
                case webcrypto_core_1.AlgorithmNames.AesGCM.toLowerCase():
                    var _algGCM = algorithm;
                    var aad = _algGCM.additionalData ? new Buffer(_algGCM.additionalData) : new Buffer(0);
                    var tagLength = _algGCM.tagLength || 128;
                    if (type) {
                        nkey.encryptGcm(iv, data, aad || new Buffer(0), tagLength / 8, function (err, data) {
                            if (err)
                                reject(err);
                            else
                                resolve(data.buffer);
                        });
                    }
                    else {
                        nkey.decryptGcm(iv, data, aad || new Buffer(0), tagLength / 8, function (err, data) {
                            if (err)
                                reject(err);
                            else
                                resolve(data.buffer);
                        });
                    }
                    break;
                case webcrypto_core_1.AlgorithmNames.AesCBC.toLowerCase():
                    var _algCBC = "CBC";
                    if (type)
                        nkey.encrypt(_algCBC, iv, data, function (err, data) {
                            if (err)
                                reject(err);
                            else
                                resolve(data.buffer);
                        });
                    else
                        nkey.decrypt(_algCBC, iv, data, function (err, data) {
                            if (err)
                                reject(err);
                            else
                                resolve(data.buffer);
                        });
                    break;
                default: throw new webcrypto_core_1.AlgorithmError(webcrypto_core_1.AlgorithmError.NOT_SUPPORTED, algorithm.name);
            }
        });
    };
    AesCrypto.WrapUnwrap = function (key, data, enc) {
        return new Promise(function (resolve, reject) {
            var fn = enc ? key.wrapKey : key.unwrapKey;
            fn.call(key, data, function (err, data) {
                if (err)
                    reject(err);
                else
                    resolve(data);
            });
        });
    };
    AesCrypto.encrypt = function (algorithm, key, data) {
        if (algorithm.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.AesKW) {
            return this.WrapUnwrap(key.native, data, true);
        }
        else
            return this.EncryptDecrypt(algorithm, key, data, true);
    };
    AesCrypto.decrypt = function (algorithm, key, data) {
        if (algorithm.name.toUpperCase() === webcrypto_core_1.AlgorithmNames.AesKW) {
            return this.WrapUnwrap(key.native, data, false);
        }
        else
            return this.EncryptDecrypt(algorithm, key, data, false);
    };
    return AesCrypto;
}(webcrypto_core_1.BaseCrypto));
exports.AesCrypto = AesCrypto;
