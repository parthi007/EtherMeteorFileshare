"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var webcrypto = require("webcrypto-core");
var AlgorithmError = webcrypto.AlgorithmError;
var WebCryptoError = webcrypto.WebCryptoError;
var AlgorithmNames = webcrypto.AlgorithmNames;
var BaseCrypto = webcrypto.BaseCrypto;
var Base64Url = webcrypto.Base64Url;
var key_1 = require("../key");
var native = require("../native");
var aes = require("./aes");
function nc2ssl(nc) {
    var _namedCurve = "";
    switch (nc.toUpperCase()) {
        case "P-192":
            _namedCurve = "secp192r1";
            break;
        case "P-256":
            _namedCurve = "secp256r1";
            break;
        case "P-384":
            _namedCurve = "secp384r1";
            break;
        case "P-521":
            _namedCurve = "secp521r1";
            break;
        default:
            throw new WebCryptoError("Unsupported namedCurve in use");
    }
    return native.EcNamedCurves[_namedCurve];
}
function b64_decode(b64url) {
    return new Buffer(Base64Url.decode(b64url));
}
function buf_pad(buf, padSize) {
    if (padSize === void 0) { padSize = 0; }
    if (padSize && Buffer.length < padSize) {
        var pad = new Buffer(new Uint8Array(padSize - buf.length).map(function (v) { return 0; }));
        return Buffer.concat([pad, buf]);
    }
    return buf;
}
var EcCrypto = (function (_super) {
    __extends(EcCrypto, _super);
    function EcCrypto() {
        return _super.apply(this, arguments) || this;
    }
    EcCrypto.generateKey = function (algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var _algorithm = algorithm;
            var namedCurve = nc2ssl(_algorithm.namedCurve);
            native.Key.generateEc(namedCurve, function (err, key) {
                if (err)
                    reject(err);
                else {
                    var prvUsages = ["sign", "deriveKey", "deriveBits"]
                        .filter(function (usage) { return keyUsages.some(function (keyUsage) { return keyUsage === usage; }); });
                    var pubUsages = ["verify"]
                        .filter(function (usage) { return keyUsages.some(function (keyUsage) { return keyUsage === usage; }); });
                    resolve({
                        privateKey: new key_1.CryptoKey(key, algorithm, "private", extractable, prvUsages),
                        publicKey: new key_1.CryptoKey(key, algorithm, "public", true, pubUsages)
                    });
                }
            });
        });
    };
    EcCrypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var _format = format.toLocaleLowerCase();
            var alg = algorithm;
            switch (_format) {
                case "jwk":
                    var jwk = keyData;
                    var data = {};
                    data["kty"] = jwk.kty;
                    data["crv"] = nc2ssl(jwk.crv);
                    data["x"] = b64_decode(jwk.x);
                    data["y"] = b64_decode(jwk.y);
                    var key_type_1 = native.KeyType.PUBLIC;
                    if (jwk.d) {
                        key_type_1 = native.KeyType.PRIVATE;
                        data["d"] = b64_decode(jwk.d);
                    }
                    native.Key.importJwk(data, key_type_1, function (err, key) {
                        try {
                            if (err)
                                reject(new WebCryptoError("ImportKey: Cannot import key from JWK\n" + err));
                            else {
                                var ec = new key_1.CryptoKey(key, alg, key_type_1 ? "private" : "public", extractable, keyUsages);
                                resolve(ec);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    break;
                case "pkcs8":
                case "spki":
                    if (!Buffer.isBuffer(keyData))
                        throw new WebCryptoError("ImportKey: keyData is not a Buffer");
                    var importFunction = native.Key.importPkcs8;
                    if (_format === "spki")
                        importFunction = native.Key.importSpki;
                    importFunction(keyData, function (err, key) {
                        try {
                            if (err)
                                reject(new WebCryptoError("ImportKey: Can not import key for " + format + "\n" + err.message));
                            else {
                                var ec = new key_1.CryptoKey(key, alg, format.toLocaleLowerCase() === "spki" ? "public" : "private", extractable, keyUsages);
                                resolve(ec);
                            }
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    break;
                default:
                    throw new WebCryptoError("ImportKey: Wrong format value '" + format + "'");
            }
        });
    };
    EcCrypto.exportKey = function (format, key) {
        return new Promise(function (resolve, reject) {
            var nkey = key.native;
            var type = key.type === "public" ? native.KeyType.PUBLIC : native.KeyType.PRIVATE;
            switch (format.toLocaleLowerCase()) {
                case "jwk":
                    nkey.exportJwk(type, function (err, data) {
                        try {
                            var jwk = { kty: "EC" };
                            jwk.crv = key.algorithm.namedCurve;
                            jwk.key_ops = key.usages;
                            var padSize = 0;
                            switch (jwk.crv) {
                                case "P-521":
                                    padSize = 66;
                                    break;
                            }
                            jwk.x = Base64Url.encode(buf_pad(data.x, padSize));
                            jwk.y = Base64Url.encode(buf_pad(data.y, padSize));
                            if (key.type === "private") {
                                jwk.d = Base64Url.encode(buf_pad(data.d, padSize));
                            }
                            resolve(jwk);
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                    break;
                case "spki":
                    nkey.exportSpki(function (err, raw) {
                        if (err)
                            reject(err);
                        else
                            resolve(raw.buffer);
                    });
                    break;
                case "pkcs8":
                    nkey.exportPkcs8(function (err, raw) {
                        if (err)
                            reject(err);
                        else
                            resolve(raw.buffer);
                    });
                    break;
                default:
                    throw new WebCryptoError("ExportKey: Unknown export format '" + format + "'");
            }
        });
    };
    EcCrypto.sign = function (algorithm, key, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _alg = _this.wc2ssl(algorithm);
            var nkey = key.native;
            nkey.sign(_alg, data, function (err, signature) {
                if (err)
                    reject(new WebCryptoError("NativeError: " + err.message));
                else {
                    resolve(signature.buffer);
                }
            });
        });
    };
    EcCrypto.verify = function (algorithm, key, signature, data) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _alg = _this.wc2ssl(algorithm);
            var nkey = key.native;
            nkey.verify(_alg, data, signature, function (err, res) {
                if (err)
                    reject(new WebCryptoError("NativeError: " + err.message));
                else
                    resolve(res);
            });
        });
    };
    EcCrypto.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var _derivedKeyType = derivedKeyType;
            var _algorithm = algorithm;
            var AesClass;
            switch (_derivedKeyType.name.toLowerCase()) {
                case AlgorithmNames.AesCBC.toLowerCase():
                case AlgorithmNames.AesGCM.toLowerCase():
                case AlgorithmNames.AesKW.toLowerCase():
                    AesClass = aes.AesCrypto;
                    break;
                default:
                    throw new AlgorithmError(AlgorithmError.NOT_SUPPORTED, _derivedKeyType.name);
            }
            baseKey.native.EcdhDeriveKey(_algorithm.public.native, _derivedKeyType.length / 8, function (err, raw) {
                if (err)
                    reject(err);
                else {
                    AesClass.importKey("raw", raw, _derivedKeyType, extractable, keyUsages)
                        .then(resolve, reject);
                }
            });
        });
    };
    EcCrypto.deriveBits = function (algorithm, baseKey, length) {
        return new Promise(function (resolve, reject) {
            var _algorithm = algorithm;
            baseKey.native.EcdhDeriveBits(_algorithm.public.native, length, function (err, raw) {
                if (err)
                    reject(err);
                else
                    resolve(raw.buffer);
            });
        });
    };
    EcCrypto.wc2ssl = function (alg) {
        var _alg = alg.hash.name.toUpperCase().replace("-", "");
        return _alg;
    };
    return EcCrypto;
}(BaseCrypto));
exports.EcCrypto = EcCrypto;
