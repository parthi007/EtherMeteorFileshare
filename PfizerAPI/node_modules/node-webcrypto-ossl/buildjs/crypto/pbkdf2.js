"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Core = require("webcrypto-core");
var key_1 = require("../key");
var aes_1 = require("./aes");
var hmac_1 = require("./hmac");
var native = require("../native");
function b64_decode(b64url) {
    return new Buffer(Core.Base64Url.decode(b64url));
}
var Pbkdf2Crypto = (function (_super) {
    __extends(Pbkdf2Crypto, _super);
    function Pbkdf2Crypto() {
        return _super.apply(this, arguments) || this;
    }
    Pbkdf2Crypto.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
        return new Promise(function (resolve, reject) {
            var _format = format.toLocaleLowerCase();
            var _alg = algorithm;
            _alg.name = _alg.name.toUpperCase();
            var raw;
            switch (_format) {
                case "jwk":
                    raw = b64_decode(keyData.k);
                    break;
                case "raw":
                    raw = keyData;
                    break;
                default:
                    throw new Core.WebCryptoError("ImportKey: Wrong format value '" + format + "'");
            }
            _alg.length = raw.byteLength * 8;
            native.Pbkdf2Key.importKey(raw, function (err, key) {
                if (err)
                    reject(err);
                else
                    resolve(new key_1.CryptoKey(key, algorithm, "secret", extractable, keyUsages));
            });
        });
    };
    Pbkdf2Crypto.deriveKey = function (algorithm, baseKey, derivedKeyType, extractable, keyUsages) {
        var _this = this;
        return Promise.resolve()
            .then(function () {
            return _this.deriveBits(algorithm, baseKey, derivedKeyType.length);
        })
            .then(function (raw) {
            var CryptoClass;
            switch (derivedKeyType.name.toUpperCase()) {
                case Core.AlgorithmNames.AesCBC:
                case Core.AlgorithmNames.AesGCM:
                case Core.AlgorithmNames.AesKW:
                    CryptoClass = aes_1.AesCrypto;
                    break;
                case Core.AlgorithmNames.Hmac:
                    CryptoClass = hmac_1.HmacCrypto;
                    break;
                default:
                    throw new Core.AlgorithmError(Core.AlgorithmError.UNSUPPORTED_ALGORITHM, algorithm.name);
            }
            return CryptoClass.importKey("raw", new Buffer(raw), derivedKeyType, extractable, keyUsages);
        });
    };
    Pbkdf2Crypto.deriveBits = function (algorithm, baseKey, length) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var _algorithm = algorithm;
            var hash = Core.PrepareAlgorithm(_algorithm.hash);
            var salt = new Buffer(Core.PrepareData(_algorithm.salt, "salt"));
            baseKey.native.deriveBits(_this.wc2ssl(hash), salt, _algorithm.iterations, length, function (err, raw) {
                if (err)
                    reject(err);
                else
                    resolve(raw.buffer);
            });
        });
    };
    Pbkdf2Crypto.wc2ssl = function (alg) {
        var _alg = alg.name.toUpperCase().replace("-", "");
        return _alg;
    };
    return Pbkdf2Crypto;
}(Core.BaseCrypto));
exports.Pbkdf2Crypto = Pbkdf2Crypto;
